/*
 * ART-2a-Euclid Clustering for Java
 * Copyright (C) 2025 Jonas Schaub, Betuel Sevindik, Achim Zielesny
 *
 * Source code is available at 
 * <https://github.com/JonasSchaub/ART2a-Clustering-for-Java>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package de.unijena.cheminf.clustering.art2a;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Random;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.logging.Level;
import java.util.logging.Logger;

import static java.util.concurrent.Executors.newFixedThreadPool;

/**
 * ART-2a-Euclid algorithm implementation for unsupervised, open categorical 
 * clustering.
 * <br><br>
 * Literature: G.A. Carpenter, S. Grossberg and D.B. Rosen, Neural Networks 4 
 * (1991) 493-504; D. Wienke, Neural Resonance and Adaptation - Towards 
 * Natureâ€™s Principles in Artificial Pattern Recognition, in L. Buydens and 
 * W. Melssen (Eds.), Chemometrics: Exploring and Exploiting Chemical 
 * Information, Catholic University Nijmegen, 1994.
 * <br><br>
 * Use Art2aEuclidKernel for sequential clustering instances and Art2aEuclidTask 
 * for clustering instances to be executed concurrently (parallelized). See 
 * hints for ART-2a-Euclid clustering with minimal additional memory allocation 
 * or maximum speed below. 
 * <br><br>
 * Note: For clustering of the SAME data with DIFFERENT vigilance parameters use
 * method getClusterResults() where the mode of calculation may be specified to 
 * be sequential or concurrent (parallelized).
 * <br><br>
 * All numerical calculations are performed in single (float) precision.
 * <br><br>
 * Note, that aDataMatrix may contain data vectors with all components being 
 * equal to zero (or some constant minimal value). These data vectors are 
 * removed from the clustering process and their indices are returned by method 
 * getZeroLengthDataVectorIndices() of an Art2aEuclidResult object.
 * <br><br>
 * ART-2a-Euclid clustering with minimal memory allocation:
 * If a data matrix with N data row vectors is used to construct a clustering 
 * instance without preprocessing (parameter isDataPreprocessing is set to 
 * false), minimal additional memory is allocated. The data matrix itself is not 
 * changed. The additional allocated memory can be controlled by the 
 * maximumNumberOfClusters parameter and estimated to be about
 * (additional memory of ART-2a-Euclid instance) = 
 * (2 x maximumNumberOfClusters / N) x (memory of data matrix), 
 * e.g., a 10 MByte data matrix with a maximum number of clusters of 10% of the 
 * number of data row vectors will lead to roughly 2 MByte of additionally 
 * allocated memory. Note, that memory for cluster vectors is only allocated if 
 * needed, e.g. if specified parameter maximumNumberOfClusters allows 150 
 * clusters but only 27 are needed, then only memory for these 27 cluster 
 * vectors is allocated. The minimal memory allocation comes at the expense of 
 * clustering speed since preprocessing steps have to be executed repeatedly. 
 * This also decreases the performance of some methods of the Art2aEuclidResult 
 * object generated by the clustering process, e.g. getClusterRepresentatives().
 * <br><br>
 * ART-2a-Euclid clustering with maximum speed:
 * If parameter isDataPreprocessing is set to true, preprocessing steps are 
 * calculated in advance for maximum clustering speed (as well as maximum speed 
 * of the Art2aResult methods). This requires an additional memory allocation 
 * for the preprocessed data for an ART-2a-Euclid clustering instance:
 * (additional memory of ART-2a instance) = 
 * (1 + 2 x maximumNumberOfClusters / N) x (memory of data matrix), 
 * e.g., a 10 MByte data matrix with a maximum number of clusters of 10% of the 
 * number of data row vectors will lead to roughly 12 MByte of additionally 
 * allocated memory.
 * <br><br>
 * CAUTION: Construction of several ART-2a-Euclid clustering instances with the 
 * SAME data matrix PLUS preprocessing is NOT advised due to the significant 
 * memory consumption of each instance. In this case, the data matrix should be 
 * checked with static method Art2aKernel.isDataMatrixValid() (where possible NaN
 * values can be removed with Utils.isNonFiniteComponentRemoval()) and then a priori
 * converted into a preprocessed Art2aEuclidData object with static method 
 * Art2aEuclidKernel.getArt2aEuclidData(). The generated Art2aData object does 
 * NOT change or refer to the data matrix so that the data matrix memory could 
 * be released after conversion (by setting the data matrix object to null). 
 * The generated Art2aEuclidData object has additionally allocated about the 
 * same memory as the original data matrix, e.g., a 10 MByte data matrix is 
 * converted into a roughly 10 MByte Art2aData object. But this single 
 * Art2aEuclidData object can now be used to construct several ART-2a-Euclid 
 * clustering instances (Art2aEuclidKernel instances or Art2aEuclidTask 
 * instances for concurrent (parallelized) execution) where each of these 
 * ART-2a-Euclid clustering instances (and their generated Art2aEuclidResult 
 * object methods) performs with maximum speed and allocates only the minimal 
 * additional memory of 
 * (additional memory of ART-2a instance) = 
 * (2 x maximumNumberOfClusters / N) x (memory of data matrix), 
 * e.g., for 9 constructed ART-2a-Euclid clustering instances for concurrent 
 * execution only 18 MBytes of additional memory are allocated in total. 
 * Compare this total additional allocated memory of only 10 + 18 = 28 MByte 
 * for an Art2aEuclidData object plus 9 ART-2a-Euclid clustering instances with 
 * the alternative 9 x 12 = 108 MByte of memory for 9 ART-2a-Euclid clustering 
 * instances constructed with the same data matrix plus independent 
 * preprocessing in each instance! (Just for completeness: For a minimal memory 
 * realization of these 9 ART-2a-Euclid clustering instances, each instance can 
 * be constructed with the same data matrix WITHOUT preprocessing, which would 
 * require only 18 MBytes of additional allocated memory in total.)
 *
 * @author Achim Zielesny
 */
public class Art2aEuclidKernel {

    //<editor-fold desc="Private static final LOGGER" defaultstate="collapsed">
    /**
     * Logger of this class
     */
    private static final Logger LOGGER = Logger.getLogger(Art2aEuclidKernel.class.getName());
    //</editor-fold>
    //<editor-fold desc="Private static final class constants" defaultstate="collapsed">
    /**
     * Value 1.0
     */
    private static final float ONE = 1.0f;
    /**
     * Default fraction of the (maximum) number of clusters relative to 
     * number of data vectors
     */
    private static final float DEFAULT_FRACTION_OF_CLUSTERS = 0.2f;
    /**
     * Default seed value for random number generator
     */
    private static final long DEFAULT_RANDOM_SEED = 1L;
    /**
     * Default maximum number of epochs
     */
    private static final int DEFAULT_MAXIMUM_NUMBER_OF_EPOCHS = 10;
    /**
     * Default value for the learning parameter
     */
    private static final float DEFAULT_LEARNING_PARAMETER = 0.01f;
    /**
     * Default offset for contrast enhancement
     */
    private static final float DEFAULT_OFFSET_FOR_CONTRAST_ENHANCEMENT = 1.0f;
    /**
     * Default value of the convergence threshold for cluster centroid 
     * distance
     */
    private static final float DEFAULT_CONVERGENCE_THRESHOLD = 0.1f;
    //</editor-fold>
    //<editor-fold desc="Private final class variables" defaultstate="collapsed">
    /**
     * Maximum number of clusters in interval [2, number of data row vectors of getDataMatrix]
     */
    private final int maximumNumberOfClusters;
    /**
     * Maximum number of epochs for training
     */
    private final int maximumNumberOfEpochs;
    /**
     * Convergence threshold for cluster centroid distance
     */
    private final float convergenceThreshold;
    /**
     * Learning parameter in interval (0,1)
     */
    private final float learningParameter;
    /**
     * Random seed value
     */
    private final long randomSeed;
    /**
     * Art2aEuclidData data object
     */
    private final Art2aEuclidData art2aEuclidData;
    //</editor-fold>
    //<editor-fold desc="Private helper callable" defaultstate="collapsed">
    /**
     * Helper callable for a single getClusterResult() calculation task of 
     * Art2aEuclidKernel with a distinct vigilance parameter.
     * <br><br>
     * Note: No checks are performed.
     */
    private static class HelperTask implements Callable<Art2aEuclidResult> {

        //<editor-fold desc="Private static final LOGGER" defaultstate="collapsed">
        /**
         * Logger of this class
         */
        private static final Logger LOGGER = Logger.getLogger(HelperTask.class.getName());
        //</editor-fold>
        //<editor-fold desc="Private final class variables" defaultstate="collapsed">
        /**
         * Art2aEuclidKernel
         */
        private final Art2aEuclidKernel art2aKernel;
        /**
         * Vigilance parameter
         */
        private final float vigilance;
        //</editor-fold>

        //<editor-fold desc="Constructor" defaultstate="collapsed">
        /**
         * Constructor
         */
        protected HelperTask(
            Art2aEuclidKernel anArt2aEuclidKernel,
            float aVigilance
        ) {
            this.art2aKernel = anArt2aEuclidKernel;
            this.vigilance = aVigilance;
        }
        //</editor-fold>

        // <editor-fold defaultstate="collapsed" desc="Overriden call() method">
        /**
         * Performs single getClusterResult() calculation task.
         *
         * @return Art2aEuclidResult or null if getClusterResult() calculation task 
 could not be performed.
         */
        @Override
        public Art2aEuclidResult call() {
            try {
                return this.art2aKernel.getClusterResult(this.vigilance);
            } catch (Exception anException) {
                HelperTask.LOGGER.log(
                    Level.SEVERE, 
                    "SingleTask.call: Can not calculate a cluster result."
                );
                HelperTask.LOGGER.log(
                    Level.SEVERE, 
                    anException.toString(), 
                    anException
                );
                return null;
            }
        }
        //</editor-fold>
    
    }
    //</editor-fold>

    // <editor-fold defaultstate="collapsed" desc="Public constructors">
    /**
     * Constructor.
     *
     * @param aDataMatrix Data matrix with data row vectors (IS NOT CHANGED)
     * @param aMaximumNumberOfClusters Maximum number of clusters (must be in 
     * interval [2, number of data row vectors of aDataMatrix])
     * @param aMaximumNumberOfEpochs Maximum number of epochs for training 
     * (must be greater zero)
     * @param aConvergenceThreshold Convergence threshold for cluster centroid 
     * distance (must be greater zero)
     * @param aLearningParameter Learning parameter (must be in interval (0,1))
     * @param anOffsetForContrastEnhancement Offset for contrast enhancement 
     * (must be greater zero)
     * @param aRandomSeed Random seed value for random number generator 
     * (must be greater zero)
     * @param anIsDataPreprocessing True: Data preprocessing is used, false:
     * Otherwise.
     * @throws IllegalArgumentException Thrown if an argument is illegal
     *
     */
    public Art2aEuclidKernel(
        float[][] aDataMatrix, 
        int aMaximumNumberOfClusters,
        int aMaximumNumberOfEpochs, 
        float aConvergenceThreshold, 
        float aLearningParameter,
        float anOffsetForContrastEnhancement,
        long aRandomSeed,
        boolean anIsDataPreprocessing
    ) throws IllegalArgumentException {
        // <editor-fold defaultstate="collapsed" desc="Checks">
        if(!Utils.isDataMatrixValid(aDataMatrix)) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.Constructor: aDataMatrix is not valid."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.Constructor: aDataMatrix is not valid.");
        }
        if(aMaximumNumberOfEpochs <= 0) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.Constructor: aMaximumNumberOfEpochs must be greater zero."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.Constructor: aMaximumNumberOfEpochs must be greater zero.");
        }
        if(aConvergenceThreshold <= 0.0f) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.Constructor: aConvergenceThreshold must be greater zero."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.Constructor: aConvergenceThreshold must be greater zero.");
        }
        if(aLearningParameter <= 0.0f || aLearningParameter >= 1.0f) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.Constructor: aLearningParameter must be in interval (0,1)."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.Constructor: aLearningParameter must be in interval (0,1).");
        }
        if(anOffsetForContrastEnhancement <= 0.0f) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.Constructor: anOffsetForContrastEnhancement must be greater zero."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.Constructor: anOffsetForContrastEnhancement must be greater zero.");
        }
        if(aRandomSeed <= 0L) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.Constructor: aRandomSeed must be greater 0."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.Constructor: aRandomSeed must be greater/equal 0.");
        }
        //</editor-fold>

        if(anIsDataPreprocessing) {
            this.art2aEuclidData = 
                Art2aEuclidKernel.getPreprocessedArt2aEuclidData(
                    aDataMatrix,
                    anOffsetForContrastEnhancement
                );
        } else {
            this.art2aEuclidData = 
                new Art2aEuclidData(
                    aDataMatrix, 
                    Utils.getMinMaxComponents(aDataMatrix),
                    anOffsetForContrastEnhancement
                );
        }

        this.maximumNumberOfClusters = aMaximumNumberOfClusters;
        this.maximumNumberOfEpochs = aMaximumNumberOfEpochs;
        this.convergenceThreshold = aConvergenceThreshold;
        this.learningParameter = aLearningParameter;
        this.randomSeed = aRandomSeed;
    }

    /**
     * Constructor with default values for DEFAULT_FRACTION_OF_CLUSTERS (= 0.2), 
     * MAXIMUM_NUMBER_OF_EPOCHS (= 10), CONVERGENCE_THRESHOLD (= 0.1), 
     * LEARNING_PARAMETER (= 0.01), DEFAULT_OFFSET_FOR_CONTRAST_ENHANCEMENT 
     * (= 0.5) and RANDOM_SEED (= 1).
     * Note: There is NO data preprocessing.
     * 
     * @param aDataMatrix Data matrix with data row vectors (IS NOT CHANGED)
     * @throws IllegalArgumentException Thrown if argument is illegal
     */
    public Art2aEuclidKernel(
        float[][] aDataMatrix
    ) throws IllegalArgumentException {
        this(
            aDataMatrix,
            Math.max((int) (aDataMatrix.length * DEFAULT_FRACTION_OF_CLUSTERS), 2),
            DEFAULT_MAXIMUM_NUMBER_OF_EPOCHS, 
            DEFAULT_CONVERGENCE_THRESHOLD, 
            DEFAULT_LEARNING_PARAMETER,
            DEFAULT_OFFSET_FOR_CONTRAST_ENHANCEMENT,
            DEFAULT_RANDOM_SEED,
            false
        );
    }
    
    /**
     * Constructor.
     *
     * @param aPreprocessedArt2aEuclidData Preprocessed ART-2a-Euclid data object
     * created by method Art2aEuclidKernel.getPreprocessedArt2aEuclidData()
     * @param aMaximumNumberOfClusters Maximum number of clusters (must be in 
     * interval [2, number of data row vectors of aDataMatrix])
     * @param aMaximumNumberOfEpochs Maximum number of epochs for training 
     * (must be greater zero)
     * @param aConvergenceThreshold Convergence threshold for cluster centroid 
     * distance (must be greater zero)
     * @param aLearningParameter Learning parameter (must be in interval (0,1))
     * @param aRandomSeed Random seed value for random number generator 
     * (must be greater zero)
     * @throws IllegalArgumentException Thrown if an argument is illegal
     */
    public Art2aEuclidKernel(
        Art2aEuclidData aPreprocessedArt2aEuclidData,
        int aMaximumNumberOfClusters,
        int aMaximumNumberOfEpochs, 
        float aConvergenceThreshold, 
        float aLearningParameter,
        long aRandomSeed
    ) throws IllegalArgumentException {
        // <editor-fold defaultstate="collapsed" desc="Checks">
        if(aPreprocessedArt2aEuclidData == null) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.Constructor: anArt2aEuclidData is null."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.Constructor: anArt2aEuclidData is null.");
        }
        if(aMaximumNumberOfEpochs <= 0) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.Constructor: aMaximumNumberOfEpochs must be greater zero."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.Constructor: aMaximumNumberOfEpochs must be greater zero.");
        }
        if(aConvergenceThreshold <= 0.0f) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.Constructor: aConvergenceThreshold must be greater zero."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.Constructor: aConvergenceThreshold must be greater zero.");
        }
        if(aLearningParameter <= 0.0f || aLearningParameter >= 1.0f) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.Constructor: aLearningParameter must be in interval (0,1)."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.Constructor: aLearningParameter must be in interval (0,1).");
        }
        if(aRandomSeed <= 0L) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.Constructor: aRandomSeed must be greater 0."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.Constructor: aRandomSeed must be greater/equal 0.");
        }
        //</editor-fold>

        this.art2aEuclidData = aPreprocessedArt2aEuclidData;
        this.maximumNumberOfClusters = aMaximumNumberOfClusters;
        this.maximumNumberOfEpochs = aMaximumNumberOfEpochs;
        this.convergenceThreshold = aConvergenceThreshold;
        this.learningParameter = aLearningParameter;
        this.randomSeed = aRandomSeed;
    }

    /**
     * Constructor with default values for DEFAULT_FRACTION_OF_CLUSTERS (= 0.2), 
     * MAXIMUM_NUMBER_OF_EPOCHS (= 10), CONVERGENCE_THRESHOLD (= 0.1), 
     * LEARNING_PARAMETER (= 0.01) and RANDOM_SEED (= 1).
     *
     * @param aPreprocessedArt2aEuclidData Preprocessed ART-2a-Euclid data object created by method
     * Art2aEuclidKernel.getPreprocessedArt2aEuclidData()
     * @throws IllegalArgumentException Thrown if argument is illegal
     */
    public Art2aEuclidKernel(
        Art2aEuclidData aPreprocessedArt2aEuclidData
    ) throws IllegalArgumentException {
        this(
            aPreprocessedArt2aEuclidData,
            Math.max((int) (aPreprocessedArt2aEuclidData.getContrastEnhancedMatrix().length * DEFAULT_FRACTION_OF_CLUSTERS), 2),
            DEFAULT_MAXIMUM_NUMBER_OF_EPOCHS, 
            DEFAULT_CONVERGENCE_THRESHOLD, 
            DEFAULT_LEARNING_PARAMETER,
            DEFAULT_RANDOM_SEED
        );
    }
    //</editor-fold>

    // <editor-fold defaultstate="collapsed" desc="Public methods">
    /**
     * Performs ART-2a-Euclid clustering and returns corresponding 
     * Art2aEuclidResult.
     *
     * @param aVigilance Vigilance parameter (must be in interval (0,1))
     * @return Art2aEuclidResult instance
     * @throws IllegalArgumentException Thrown if argument is illegal
     * @throws Exception Thrown if exception occurs which should never happen
     */
    public Art2aEuclidResult getClusterResult(
        float aVigilance
    ) throws Exception {
        // <editor-fold defaultstate="collapsed" desc="Checks">
        if(aVigilance <= 0.0f || aVigilance >= 1.0f) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.getClusterResult: aVigilance must be in interval (0,1)."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.getClusterResult: aVigilance must be in interval (0,1).");
        }
        //</editor-fold>
        
        try {
            Random tmpRandomNumberGenerator = new Random(this.randomSeed);
            boolean tmpIsClusterOverflow = false;
            
            float[][] tmpDataMatrix = null;
            float[][] tmpContrastEnhancedMatrix = null;
            // Flags array that indicates if data row vectors have a length 
            // of zero (i.e. where all components are equal to zero). True: 
            // Data row vector has a length of zero, false: Otherwise.
            boolean[] tmpDataVectorZeroLengthFlags = null;
            int tmpNumberOfComponents = -1;
            int tmpNumberOfDataVectors = -1;
            if (this.art2aEuclidData.hasPreprocessedData()) {
                tmpContrastEnhancedMatrix = this.art2aEuclidData.getContrastEnhancedMatrix();
                tmpDataVectorZeroLengthFlags = this.art2aEuclidData.getDataVectorZeroLengthFlags();
                tmpNumberOfDataVectors = tmpContrastEnhancedMatrix.length;
                tmpNumberOfComponents = tmpContrastEnhancedMatrix[0].length;
            } else {
                tmpDataMatrix = this.art2aEuclidData.getDataMatrix();
                tmpDataVectorZeroLengthFlags = new boolean[tmpDataMatrix.length];
                Utils.fillVector(tmpDataVectorZeroLengthFlags, false);
                tmpNumberOfDataVectors = tmpDataMatrix.length;
                tmpNumberOfComponents = tmpDataMatrix[0].length;
            }
            Utils.MinMaxValue[] tmpMinMaxComponents = this.art2aEuclidData.getMinMaxComponentsOfDataMatrix();
            
            // Set tmpRhoStar
            float tmpRhoStar = tmpNumberOfComponents * (ONE - aVigilance);

            // Definitions
            float tmpThresholdForContrastEnhancement = 
                Utils.getThresholdForContrastEnhancement(
                    tmpNumberOfComponents,
                    this.art2aEuclidData.getOffsetForContrastEnhancement()
                );
            // Scaling factor alpha
            float tmpScalingFactor = tmpThresholdForContrastEnhancement;
            
            // Initialize cluster matrix and that for previous epoch (old) with 
            // all row vectors being null
            float[][] tmpClusterMatrix = new float[this.maximumNumberOfClusters][];
            float[][] tmpClusterMatrixOld = new float[this.maximumNumberOfClusters][];
            // Cluster usage flags. True: Cluster is used, false: Cluster is 
            // empty and can be removed.
            boolean[] tmpClusterUsageFlags = new boolean[this.maximumNumberOfClusters];

            // Initialize cluster indices for data row vectors with -1 to 
            // indicate missing cluster assignment
            int[] tmpClusterIndexOfDataVector = new int[tmpNumberOfDataVectors];
            Utils.fillVector(tmpClusterIndexOfDataVector, -1);

            // Initialize random indices
            int[] tmpRandomIndices = new int[tmpNumberOfDataVectors];
            for(int i = 0; i < tmpRandomIndices.length; i++) {
                tmpRandomIndices[i] = i;
            }

            // Initialize buffer vector for vector operations
            float[] tmpBufferVector = new float[tmpNumberOfComponents];
            
            // Main clustering loop
            int tmpCurrentNumberOfEpochs = 0;
            int tmpNumberOfDetectedClusters = 0;
            Utils.RhoWinner tmpRhoWinner = new Utils.RhoWinner();
            Utils.ClusterRemovalInfo tmpClusterRemovalInfo = new Utils.ClusterRemovalInfo();
            boolean tmpIsConverged = false;
            while(!tmpIsConverged && tmpCurrentNumberOfEpochs < this.maximumNumberOfEpochs) {
                tmpCurrentNumberOfEpochs++;
                
                // Get random sequence of indices for data row vectors
                Utils.shuffleIndices(tmpRandomIndices, tmpRandomNumberGenerator);

                Arrays.fill(tmpClusterUsageFlags, false);
                for(int i = 0; i < tmpNumberOfDataVectors; i++) {
                    int tmpRandomIndex = tmpRandomIndices[i];
    
                    if (tmpDataVectorZeroLengthFlags[tmpRandomIndex]) {
                        // Shifted data row vector has length of zero: Ignore!
                        continue;
                    }

                    if (this.art2aEuclidData.hasPreprocessedData()) {
                        Utils.copyVector(tmpContrastEnhancedMatrix[tmpRandomIndex], tmpBufferVector);
                    } else {
                        tmpDataVectorZeroLengthFlags[tmpRandomIndex] = 
                            Art2aEuclidUtils.setContrastEnhancedVector(
                                tmpDataMatrix[tmpRandomIndex],
                                tmpBufferVector,
                                tmpMinMaxComponents,
                                tmpThresholdForContrastEnhancement
                            );
                        if (tmpDataVectorZeroLengthFlags[tmpRandomIndex]) {
                            continue;
                        }
                    }

                    if(tmpNumberOfDetectedClusters == 0) {
                        // Create first cluster
                        Utils.setRowVector(tmpClusterMatrix, tmpBufferVector, tmpNumberOfDetectedClusters);
                        tmpClusterIndexOfDataVector[tmpRandomIndex] = tmpNumberOfDetectedClusters;
                        tmpClusterUsageFlags[tmpNumberOfDetectedClusters] = true;
                        tmpNumberOfDetectedClusters++;
                    } else {
                        // Cluster number is greater than or equal to 1
                        Art2aEuclidUtils.setRhoWinner(
                            tmpBufferVector, 
                            tmpClusterMatrix, 
                            tmpNumberOfDetectedClusters, 
                            tmpScalingFactor,
                            tmpRhoWinner
                        );
                        // Assign to existing cluster or increment clusters
                        if(tmpRhoWinner.getIndexOfCluster() < 0 || tmpRhoWinner.getRhoValue() > tmpRhoStar) {
                            // Increment clusters (if possible)
                            if (tmpNumberOfDetectedClusters == this.maximumNumberOfClusters) {
                                tmpIsClusterOverflow = true;
                            } else {
                                // Increment clusters
                                Utils.setRowVector(tmpClusterMatrix, tmpBufferVector, tmpNumberOfDetectedClusters);
                                tmpClusterIndexOfDataVector[tmpRandomIndex] = tmpNumberOfDetectedClusters;
                                tmpClusterUsageFlags[tmpNumberOfDetectedClusters] = true;
                                tmpNumberOfDetectedClusters++;
                            }
                        } else {
                            // Assign to existing winner cluster with modification
                            // Note: tmpBufferVector (= contrast enhanced unit vector)
                            // is used for modification
                            Art2aEuclidUtils.modifyWinnerCluster(
                                tmpBufferVector,
                                tmpClusterMatrix[tmpRhoWinner.getIndexOfCluster()],
                                tmpThresholdForContrastEnhancement,
                                this.learningParameter
                            );
                            tmpClusterIndexOfDataVector[tmpRandomIndex] = tmpRhoWinner.getIndexOfCluster();
                            tmpClusterUsageFlags[tmpRhoWinner.getIndexOfCluster()] = true;
                        }
                    }
                }
                
                Utils.removeEmptyClusters(
                    tmpClusterUsageFlags, 
                    tmpClusterMatrix, 
                    tmpNumberOfDetectedClusters, 
                    tmpClusterRemovalInfo
                );
                if (tmpClusterRemovalInfo.isClusterRemoved()) {
                    tmpNumberOfDetectedClusters = tmpClusterRemovalInfo.getNumberOfDetectedClusters();
                    tmpIsConverged = false;
                } else {
                    tmpIsConverged = 
                        Art2aEuclidUtils.isConverged(
                            tmpNumberOfDetectedClusters, 
                            tmpCurrentNumberOfEpochs, 
                            tmpClusterMatrix, 
                            tmpClusterMatrixOld,
                            this.maximumNumberOfEpochs,
                            this.convergenceThreshold
                        );
                }
            }
            // Check if cluster overflow occurred
            if (tmpIsClusterOverflow) {
                // Cluster overflow occurred: Finally assign ALL data vectors
                Art2aEuclidUtils.assignDataVectorsToClusters(
                    tmpNumberOfDetectedClusters,
                    tmpDataVectorZeroLengthFlags,
                    this.art2aEuclidData,
                    tmpBufferVector,
                    tmpThresholdForContrastEnhancement,
                    tmpClusterMatrix,
                    tmpClusterIndexOfDataVector,
                    tmpClusterUsageFlags
                );
                // Remove possible empty clusters
                Utils.removeEmptyClusters(
                    tmpClusterUsageFlags, 
                    tmpClusterMatrix, 
                    tmpNumberOfDetectedClusters, 
                    tmpClusterRemovalInfo
                );
                tmpNumberOfDetectedClusters = tmpClusterRemovalInfo.getNumberOfDetectedClusters();
            }
            // Check if clusters were removed in last epoch and assure non-empty 
            // clusters in the cluster matrix
            while (tmpClusterRemovalInfo.isClusterRemoved()) {
                // Empty clusters are removed: Assign data vectors again
                Art2aEuclidUtils.assignDataVectorsToClusters(
                    tmpNumberOfDetectedClusters,
                    tmpDataVectorZeroLengthFlags,
                    this.art2aEuclidData,
                    tmpBufferVector,
                    tmpThresholdForContrastEnhancement,
                    tmpClusterMatrix,
                    tmpClusterIndexOfDataVector,
                    tmpClusterUsageFlags
                );
                Utils.removeEmptyClusters(
                    tmpClusterUsageFlags, 
                    tmpClusterMatrix, 
                    tmpNumberOfDetectedClusters, 
                    tmpClusterRemovalInfo
                );
                tmpNumberOfDetectedClusters = tmpClusterRemovalInfo.getNumberOfDetectedClusters();
            }
            return new Art2aEuclidResult(
                aVigilance,
                tmpThresholdForContrastEnhancement,
                tmpCurrentNumberOfEpochs,
                tmpNumberOfDetectedClusters, 
                tmpClusterIndexOfDataVector,
                tmpClusterMatrix,
                tmpDataVectorZeroLengthFlags,
                tmpIsClusterOverflow,
                tmpIsConverged,
                this.art2aEuclidData
            );
        } catch (Exception anException) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.getClusterResult: An exception occurred: This should never happen!"
            );
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                anException.toString(), 
                anException
            );
            throw new Exception("Art2aEuclidKernel.getClusterResult: An exception occurred: This should never happen!");
        }
    }

    /**
     * Performs ART-2a-Euclid clustering for specified vigilance parameters and 
     * returns corresponding Art2aEuclidResult objects.
     *
     * @param aVigilances Vigilance parameters (must each be in interval (0,1))
     * @return Art2aEuclidResult objects or null if clustering result could 
     * not be calculated.
     * @param aNumberOfConcurrentCalculationThreads Number of concurrent 
     * calculation threads for the different vigilance parameters to be 
     * calculated concurrently (in parallel). If zero, then the different 
     * vigilance parameters are calculated one after another (sequentially)
     * @throws IllegalArgumentException Thrown if argument is illegal
     * @throws Exception Thrown if exception occurs which should never happen
     */
    public Art2aEuclidResult[] getClusterResults(
        float[] aVigilances,
        int aNumberOfConcurrentCalculationThreads
    ) throws Exception {
        // <editor-fold defaultstate="collapsed" desc="Checks">
        if (aVigilances == null || aVigilances.length == 0) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.getClusterResults: aVigilances is null or has length 0."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.getClusterResults: aVigilances is null or has length 0.");
        }
        for (float tmpVigilance : aVigilances) {
            if(tmpVigilance <= 0.0f || tmpVigilance >= 1.0f) {
                Art2aEuclidKernel.LOGGER.log(
                    Level.SEVERE, 
                    "Art2aEuclidKernel.getClusterResults: Vigilance parameter must be in interval (0,1)."
                );
                throw new IllegalArgumentException("Art2aEuclidKernel.getClusterResults: Vigilance parameter must be in interval (0,1).");
            }
        }
        if (aNumberOfConcurrentCalculationThreads < 0) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.getClusterResults: aNumberOfConcurrentCalculationThreads must be greater or equal to 0."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.getClusterResults: aNumberOfConcurrentCalculationThreads must be greater or equal to 0.");
        }
        //</editor-fold>

        if (aNumberOfConcurrentCalculationThreads > 0) {
            LinkedList<HelperTask> tmpSingleTaskList = new LinkedList<>();
            for (float tmpVigilance : aVigilances) {
                tmpSingleTaskList.add(new HelperTask(this, tmpVigilance));
            }
            ExecutorService tmpExecutorService = newFixedThreadPool(aNumberOfConcurrentCalculationThreads);
            List<Future<Art2aEuclidResult>> tmpFutureList = null;
            try {
                tmpFutureList = tmpExecutorService.invokeAll(tmpSingleTaskList);
            } catch (InterruptedException anInterruptedException) {
                Art2aEuclidKernel.LOGGER.log(
                    Level.SEVERE, 
                    "Art2aEuclidKernel.getClusterResults: Interrupted exception during concurrent calculation: This should never happen."
                );
                throw anInterruptedException;
            }
            tmpExecutorService.shutdown();
            Art2aEuclidResult[] tmpParallelResults = new Art2aEuclidResult[aVigilances.length];
            int tmpIndex = 0;
            for (Future<Art2aEuclidResult> tmpFuture : tmpFutureList) {
                try {
                    tmpParallelResults[tmpIndex++] = tmpFuture.get();
                } catch (Exception anException) {
                    Art2aEuclidKernel.LOGGER.log(
                        Level.SEVERE, 
                        "Art2aEuclidKernel.getClusterResults: Exception in tmpFuture.get()."
                    );
                    throw anException;
                }
            }
            return tmpParallelResults;
        } else {
            Art2aEuclidResult[] tmpSequentialResults = new Art2aEuclidResult[aVigilances.length];
            for (int i = 0; i < aVigilances.length; i++) {
                tmpSequentialResults[i] = this.getClusterResult(aVigilances[i]);
            }
            return tmpSequentialResults;
        }
    }
    
    /**
     * Nearest (smaller) indices of approximants to the desired number of 
     * representatives.
     * 
     * @param aNumberOfRepresentatives Number of representatives (MUST be 
     * greater or equal to 2)
     * @param aVigilanceMin Minimal vigilance parameter (must be in interval 
     * (0,1))
     * @param aVigilanceMax Maximal vigilance parameter (must be in interval 
     * (0,1))
     * @param aNumberOfTrialSteps Number of trial steps (MUST be greater or 
     * equal to 1)
     * @return Nearest (smaller) indices of approximants to the desired number 
     * of representatives.
     * @throws IllegalArgumentException Thrown if an argument is illegal
     * @throws Exception Thrown if exception occurs which should never happen
     */
    public int[] getRepresentatives(
        int aNumberOfRepresentatives,
        float aVigilanceMin,
        float aVigilanceMax,
        int aNumberOfTrialSteps
    ) throws IllegalArgumentException, Exception {
        // <editor-fold defaultstate="collapsed" desc="Checks">
        if(aNumberOfRepresentatives < 2) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.getRepresentatives: aNumberOfRepresentatives must be greater/equal 2."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.getRepresentatives: aNumberOfRepresentatives must be greater/equal 2.");
        }
        if(aVigilanceMin <= 0.0f || aVigilanceMin >= 1.0f) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.getRepresentatives: aVigilanceMin must be in interval (0,1)."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.getRepresentatives: aVigilanceMin must be in interval (0,1).");
        }
        if(aVigilanceMax <= 0.0f || aVigilanceMax >= 1.0f) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.getRepresentatives: aVigilanceMax must be in interval (0,1)."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.getRepresentatives: aVigilanceMax must be in interval (0,1).");
        }
        if(aVigilanceMin >= aVigilanceMax) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.getRepresentatives: aVigilanceMin must be smaller than aVigilanceMax."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.getRepresentatives: aVigilanceMin must be smaller than aVigilanceMax.");
        }
        if(aNumberOfTrialSteps < 1) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.getRepresentatives: aNumberOfTrialSteps must be greater/equal 1."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.getRepresentatives: aNumberOfTrialSteps must be greater/equal 1.");
        }
        //</editor-fold>

        try {
            Art2aEuclidResult tmpArt2aEuclidResult = this.getClusterResult(aVigilanceMin);
            int[] tmpRepresentativeIndicesOfClusters = tmpArt2aEuclidResult.getRepresentativeIndicesOfClusters();
            if (tmpArt2aEuclidResult.getNumberOfDetectedClusters() > aNumberOfRepresentatives) {
                return tmpRepresentativeIndicesOfClusters;
            }
            tmpArt2aEuclidResult = this.getClusterResult(aVigilanceMax);
            if (tmpArt2aEuclidResult.getNumberOfDetectedClusters() < aNumberOfRepresentatives) {
                return tmpArt2aEuclidResult.getRepresentativeIndicesOfClusters();
            }

            float tmpVigilanceMin = aVigilanceMin;
            float tmpVigilanceMax = aVigilanceMax;
            for (int i = 0; i < aNumberOfTrialSteps; i++) {
                float tmpVigilanceMean = (tmpVigilanceMin + tmpVigilanceMax) / 2.0f;
                tmpArt2aEuclidResult = this.getClusterResult(tmpVigilanceMean);
                if (tmpArt2aEuclidResult.getNumberOfDetectedClusters() > aNumberOfRepresentatives) {
                    tmpVigilanceMax = tmpVigilanceMean;
                } else if (tmpArt2aEuclidResult.getNumberOfDetectedClusters() < aNumberOfRepresentatives) {
                    tmpVigilanceMin = tmpVigilanceMean;
                    tmpRepresentativeIndicesOfClusters = tmpArt2aEuclidResult.getRepresentativeIndicesOfClusters();
                } else {
                    return tmpArt2aEuclidResult.getRepresentativeIndicesOfClusters();
                }
            }
            return tmpRepresentativeIndicesOfClusters;
        } catch (Exception anException) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.getRepresentatives: An exception occurred: This should never happen!"
            );
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                anException.toString(), 
                anException
            );
            throw anException;
        }
    }
    
    /**
     * Note: This is a purely experimental nonsense method.
     * 
     * Returns representatives whose mean distance is nearest to the mean 
     * distance of all data vectors of specified original data matrix.
     * Note: This is a O(N^2) operation, N: Number of data vectors.
     * 
     * @param aDataMatrix Original data matrix (IS NOT CHANGED and NOT properly
     * CHECKED)
     * @param aMinimumNumberOfRepresentatives Minimum number of representatives
     * @param aMaximumNumberOfRepresentatives Maximum number of representatives
     * @return Representatives whose mean distance is nearest to the mean 
     * distance of all data vectors of specified original data matrix.
     * @throws IllegalArgumentException Thrown if an argument is illegal
     * @throws Exception Thrown if exception occurs which should never happen
     */
    public int[] getBestRepresentatives(
        float[][] aDataMatrix,
        int aMinimumNumberOfRepresentatives,
        int aMaximumNumberOfRepresentatives
    ) throws IllegalArgumentException, Exception {
        // <editor-fold defaultstate="collapsed" desc="Checks">
        if(aDataMatrix == null || aDataMatrix.length == 0) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.getBestRepresentatives: aDataMatrix is null/has length zero."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.getBestRepresentatives: aDataMatrix is null/has length zero.");
        }
        if(aMinimumNumberOfRepresentatives < 2 || aMinimumNumberOfRepresentatives > aDataMatrix.length - 1) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.getBestRepresentatives: aMinimumNumberOfRepresentatives is invalid."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.getBestRepresentatives: aMinimumNumberOfRepresentatives is invalid.");
        }
        if(aMaximumNumberOfRepresentatives <= aMinimumNumberOfRepresentatives || aMaximumNumberOfRepresentatives > aDataMatrix.length) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.getBestRepresentatives: aMaximumNumberOfRepresentatives is invalid."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.getBestRepresentatives: aMaximumNumberOfRepresentatives is invalid.");
        }
        //</editor-fold>

        try {
            int[] tmpAllIndices = new int[aDataMatrix.length];
            for (int i = 0; i < tmpAllIndices.length; i++) {
                tmpAllIndices[i] = i;
            }
            float tmpBaseMeanDistance = Utils.getMeanDistance(aDataMatrix, tmpAllIndices);

            float tmpVigilanceMin = 0.0001f;
            float tmpVigilanceMax = 0.9999f;
            int tmpNumberOfTrialSteps = 32;

            float tmpMinimalDifference = Float.MAX_VALUE;
            int[] tmpBestRepresentatives = null;
            for (int i = aMinimumNumberOfRepresentatives; i < aMaximumNumberOfRepresentatives; i++) {
                int[] tmpRepresentatives = 
                    this.getRepresentatives(
                        i, 
                        tmpVigilanceMin, 
                        tmpVigilanceMax, 
                        tmpNumberOfTrialSteps
                    );
                float tmpMeanDistance = Utils.getMeanDistance(aDataMatrix, tmpRepresentatives);
                float tmpDifference = Math.abs(tmpMeanDistance - tmpBaseMeanDistance);
                if (tmpDifference < tmpMinimalDifference) {
                    tmpMinimalDifference = tmpDifference;
                    tmpBestRepresentatives = tmpRepresentatives;
                }
            }
            return tmpBestRepresentatives;
        } catch (Exception anException) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.getBestRepresentatives: An exception occurred: This should never happen!"
            );
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                anException.toString(), 
                anException
            );
            throw anException;
        }
    }
    //</editor-fold>
    // <editor-fold defaultstate="collapsed" desc="Public static methods">
    /**
     * Creates ART-2a-Euclid data object with preprocessed data for maximum 
     * speed  of the clustering process. The ART-2a-Euclid data object allocates 
     * about the same memory as aDataMatrix.
     * <br>
     * Note: There a no checks! Check aDataMatrix in advance with method
     * Utils.isDataMatrixValid().
     * <br>
     * Note: aDataMatrix could be set to null after this operation to release  
     * its memory.

     * @param aDataMatrix Data matrix (IS NOT CHANGED and MUST BE VALID: Check 
     * with Utils.isDataMatrixValid() in advance)
     * @param anOffsetForContrastEnhancement Offset for contrast enhancement 
     * (must be greater zero)
     * @return ART-2a-Euclid data object for maximum clustering speed but with 
     * additionally allocated memory (about the same memory as aDataMatrix)
     */
    public static Art2aEuclidData getPreprocessedArt2aEuclidData(
        float[][] aDataMatrix,
        float anOffsetForContrastEnhancement
    ) {
        int tmpNumberOfComponents = aDataMatrix[0].length;
        float tmpThresholdForContrastEnhancement = 
            Utils.getThresholdForContrastEnhancement(
                tmpNumberOfComponents,
                anOffsetForContrastEnhancement
            );
        
        // Initialize flags array for scaled data row vectors which have a 
        // length of zero (i.e. where all components are equal to zero)
        boolean[] tmpDataVectorZeroLengthFlags = new boolean[aDataMatrix.length];
        Utils.fillVector(tmpDataVectorZeroLengthFlags, false);

        float[][] tmpContrastEnhancedMatrix = new float[aDataMatrix.length][];
        
        Utils.MinMaxValue[] tmpMinMaxComponents = Utils.getMinMaxComponents(aDataMatrix);

        for(int i = 0; i < aDataMatrix.length; i++) {
            float[] tmpContrastEnhancedVector = new float[tmpNumberOfComponents];
            tmpDataVectorZeroLengthFlags[i] = 
                Art2aEuclidUtils.setContrastEnhancedVector(
                    aDataMatrix[i],
                    tmpContrastEnhancedVector,
                    tmpMinMaxComponents,
                    tmpThresholdForContrastEnhancement
                );
            tmpContrastEnhancedMatrix[i] = tmpContrastEnhancedVector;
        }
        return new Art2aEuclidData(
            tmpContrastEnhancedMatrix,
            tmpDataVectorZeroLengthFlags,
            tmpMinMaxComponents,
            anOffsetForContrastEnhancement
        );
    }

    /**
     * Creates ART-2a-Euclid data object with preprocessed data for maximum 
     * speed of the clustering process. The ART-2a-Euclid data object allocates 
     * about twice the memory of aDataMatrix. A default value of 1.0 is used 
     * for the offset for contrast enhancement.
     * <br>
     * Note: aDataMatrix could be set to null after this operation to release  
     * its memory.

     * @param aDataMatrix Data matrix (IS NOT CHANGED and MUST BE VALID: Check 
     * with Utils.isDataMatrixValid() in advance)
     * @return ART-2a-Euclid data object for maximum clustering speed but with 
     * additionally allocated memory (about the same memory as aDataMatrix)
     */
    public static Art2aEuclidData getPreprocessedArt2aEuclidData(
        float[][] aDataMatrix
    ) {
        return Art2aEuclidKernel.getPreprocessedArt2aEuclidData(aDataMatrix, DEFAULT_OFFSET_FOR_CONTRAST_ENHANCEMENT);
    }
    //</editor-fold>

}
