/*
 * ART-2a-Euclid Clustering for Java
 * Copyright (C) 2025 Jonas Schaub, Betuel Sevindik, Achim Zielesny
 *
 * Source code is available at 
 * <https://github.com/JonasSchaub/ART2a-Clustering-for-Java>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package de.unijena.cheminf.clustering.art2a;

import java.util.Arrays;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.IntStream;

/**
 * ART-2a-Euclid algorithm implementation for unsupervised, open categorical 
 * clustering.
 * <br><br>
 * Literature: G.A. Carpenter, S. Grossberg and D.B. Rosen, Neural Networks 4 
 * (1991) 493-504; D. Wienke, Neural Resonance and Adaptation - Towards 
 * Natureâ€™s Principles in Artificial Pattern Recognition, in L. Buydens and 
 * W. Melssen (Eds.), Chemometrics: Exploring and Exploiting Chemical 
 * Information, Catholic University Nijmegen, 1994.
 * <br><br>
 * Use Art2aEuclidKernel for sequential clustering instances and Art2aEuclidTask 
 * for clustering instances to be executed concurrently (parallelized). See 
 * hints for ART-2a-Euclid clustering with minimal additional memory allocation 
 * or maximum speed below. 
 * <br><br>
 * Note: For clustering of the SAME data with DIFFERENT vigilance parameters use
 * method getClusterResults() where the mode of calculation may be specified to 
 * be sequential or concurrent (parallelized).
 * <br><br>
 * All numerical calculations are performed in single (float) precision.
 * <br><br>
 * Note, that aDataMatrix may contain data vectors with all components being 
 * equal to zero (or some constant minimal value). These data vectors are 
 * removed from the clustering process and their indices are returned by method 
 * getZeroLengthDataVectorIndices() of an Art2aEuclidResult object.
 * <br><br>
 * ART-2a-Euclid clustering with minimal memory allocation:
 * If a data matrix with N data row vectors is used to construct a clustering 
 * instance without preprocessing (parameter isDataPreprocessing is set to 
 * false), minimal additional memory is allocated. The data matrix itself is not 
 * changed. The additional allocated memory can be controlled by the 
 * maximumNumberOfClusters parameter and estimated to be about
 * (additional memory of ART-2a-Euclid instance) = 
 * (2 x maximumNumberOfClusters / N) x (memory of data matrix), 
 * e.g., a 10 MByte data matrix with a maximum number of clusters of 10% of the 
 * number of data row vectors will lead to roughly 2 MByte of additionally 
 * allocated memory. Note, that memory for cluster vectors is only allocated if 
 * needed, e.g. if specified parameter maximumNumberOfClusters allows 150 
 * clusters but only 27 are needed, then only memory for these 27 cluster 
 * vectors is allocated. The minimal memory allocation comes at the expense of 
 * clustering speed since preprocessing steps have to be executed repeatedly. 
 * This also decreases the performance of some methods of the Art2aEuclidResult 
 * object generated by the clustering process, e.g. getClusterRepresentatives().
 * <br><br>
 * ART-2a-Euclid clustering with maximum speed:
 * If parameter isDataPreprocessing is set to true, preprocessing steps are 
 * calculated in advance for maximum clustering speed (as well as maximum speed 
 * of the Art2aResult methods). This requires an additional memory allocation 
 * for the preprocessed data for an ART-2a-Euclid clustering instance:
 * (additional memory of ART-2a instance) = 
 * (1 + 2 x maximumNumberOfClusters / N) x (memory of data matrix), 
 * e.g., a 10 MByte data matrix with a maximum number of clusters of 10% of the 
 * number of data row vectors will lead to roughly 12 MByte of additionally 
 * allocated memory.
 * <br><br>
 * CAUTION: Construction of several ART-2a-Euclid clustering instances with the 
 * SAME data matrix PLUS preprocessing is NOT advised due to the significant 
 * memory consumption of each instance. In this case, the data matrix should be 
 * checked with static method Art2aKernel.isDataMatrixValid() (where possible NaN
 * values can be removed with Utils.isNonFiniteComponentRemoval()) and then a priori
 * converted into a preprocessed Art2aEuclidData object with static method 
 * Art2aEuclidKernel.getArt2aEuclidData(). The generated Art2aData object does 
 * NOT change or refer to the data matrix so that the data matrix memory could 
 * be released after conversion (by setting the data matrix object to null). 
 * The generated Art2aEuclidData object has additionally allocated about the 
 * same memory as the original data matrix, e.g., a 10 MByte data matrix is 
 * converted into a roughly 10 MByte Art2aData object. But this single 
 * Art2aEuclidData object can now be used to construct several ART-2a-Euclid 
 * clustering instances (Art2aEuclidKernel instances or Art2aEuclidTask 
 * instances for concurrent (parallelized) execution) where each of these 
 * ART-2a-Euclid clustering instances (and their generated Art2aEuclidResult 
 * object methods) performs with maximum speed and allocates only the minimal 
 * additional memory of 
 * (additional memory of ART-2a instance) = 
 * (2 x maximumNumberOfClusters / N) x (memory of data matrix), 
 * e.g., for 9 constructed ART-2a-Euclid clustering instances for concurrent 
 * execution only 18 MBytes of additional memory are allocated in total. 
 * Compare this total additional allocated memory of only 10 + 18 = 28 MByte 
 * for an Art2aEuclidData object plus 9 ART-2a-Euclid clustering instances with 
 * the alternative 9 x 12 = 108 MByte of memory for 9 ART-2a-Euclid clustering 
 * instances constructed with the same data matrix plus independent 
 * preprocessing in each instance! (Just for completeness: For a minimal memory 
 * realization of these 9 ART-2a-Euclid clustering instances, each instance can 
 * be constructed with the same data matrix WITHOUT preprocessing, which would 
 * require only 18 MBytes of additional allocated memory in total.)
 *
 * @author Achim Zielesny
 */
public class Art2aEuclidKernel {

    //<editor-fold desc="Private static final LOGGER">
    /**
     * Logger of this class
     */
    private static final Logger LOGGER = Logger.getLogger(Art2aEuclidKernel.class.getName());
    //</editor-fold>
    //<editor-fold desc="Private static final constants">
    /**
     * Value 1.0
     */
    private static final float ONE = 1.0f;
    //</editor-fold>
    //<editor-fold desc="Private static final class variables">
    /**
     * Default seed value for random number generator
     */
    private static final long DEFAULT_RANDOM_SEED = 1L;
    /**
     * Default maximum number of epochs
     */
    private static final int DEFAULT_MAXIMUM_NUMBER_OF_EPOCHS = 10;
    /**
     * Default value for the learning parameter
     */
    private static final float DEFAULT_LEARNING_PARAMETER = 0.01f;
    /**
     * Default offset for contrast enhancement
     */
    private static final float DEFAULT_OFFSET_FOR_CONTRAST_ENHANCEMENT = 1.0f;
    /**
     * Default value of the convergence threshold for cluster centroid 
     * distance
     */
    private static final float DEFAULT_CONVERGENCE_THRESHOLD = 0.1f;
    //</editor-fold>
    //<editor-fold desc="Private final class variables">
    /**
     * Maximum number of clusters in interval [2, number of data row vectors of getDataMatrix]
     */
    private final int maximumNumberOfClusters;
    /**
     * Maximum number of epochs for training
     */
    private final int maximumNumberOfEpochs;
    /**
     * Convergence threshold for cluster centroid distance
     */
    private final float convergenceThreshold;
    /**
     * Learning parameter in interval (0,1)
     */
    private final float learningParameter;
    /**
     * Random seed value
     */
    private final long randomSeed;
    /**
     * PreprocessedData object
     */
    private final PreprocessedData preprocessedData;
    //</editor-fold>

    // <editor-fold desc="Public constructors">
    /**
     * Constructor.
     *
     * @param aDataMatrix Data matrix with data row vectors (IS NOT CHANGED)
     * @param aMaximumNumberOfClusters Maximum number of clusters (must be in 
     * interval [2, number of data row vectors of aDataMatrix])
     * @param aMaximumNumberOfEpochs Maximum number of epochs for training 
     * (must be greater zero)
     * @param aConvergenceThreshold Convergence threshold for cluster centroid 
     * distance (must be greater zero)
     * @param aLearningParameter Learning parameter (must be in interval (0,1))
     * @param anOffsetForContrastEnhancement Offset for contrast enhancement 
     * (must be greater zero)
     * @param aRandomSeed Random seed value for random number generator 
     * (must be greater zero)
     * @param anIsDataPreprocessing True: Data preprocessing is performed, false:
     * Otherwise.
     * @throws IllegalArgumentException Thrown if an argument is illegal
     *
     */
    public Art2aEuclidKernel(
        float[][] aDataMatrix, 
        int aMaximumNumberOfClusters,
        int aMaximumNumberOfEpochs, 
        float aConvergenceThreshold, 
        float aLearningParameter,
        float anOffsetForContrastEnhancement,
        long aRandomSeed,
        boolean anIsDataPreprocessing
    ) throws IllegalArgumentException {
        // <editor-fold desc="Checks">
        if(!Utils.isDataMatrixValid(aDataMatrix)) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.Constructor: aDataMatrix is not valid."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.Constructor: aDataMatrix is not valid.");
        }
        if(aMaximumNumberOfClusters < 2) {
            Art2aEuclidKernel.LOGGER.log(
                    Level.SEVERE,
                    "Art2aEuclidKernel.Constructor: aMaximumNumberOfClusters must be greater 1."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.Constructor: aMaximumNumberOfClusters must be greater 1.");
        }
        if(aMaximumNumberOfClusters > aDataMatrix.length) {
            aMaximumNumberOfClusters = aDataMatrix.length;
        }
        if(aMaximumNumberOfEpochs <= 0) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.Constructor: aMaximumNumberOfEpochs must be greater zero."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.Constructor: aMaximumNumberOfEpochs must be greater zero.");
        }
        if(aConvergenceThreshold <= 0.0f) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.Constructor: aConvergenceThreshold must be greater zero."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.Constructor: aConvergenceThreshold must be greater zero.");
        }
        if(aLearningParameter <= 0.0f || aLearningParameter >= 1.0f) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.Constructor: aLearningParameter must be in interval (0,1)."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.Constructor: aLearningParameter must be in interval (0,1).");
        }
        if(anOffsetForContrastEnhancement <= 0.0f) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.Constructor: anOffsetForContrastEnhancement must be greater zero."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.Constructor: anOffsetForContrastEnhancement must be greater zero.");
        }
        if(aRandomSeed <= 0L) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.Constructor: aRandomSeed must be greater 0."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.Constructor: aRandomSeed must be greater/equal 0.");
        }
        //</editor-fold>

        if(anIsDataPreprocessing) {
            this.preprocessedData =
                Art2aEuclidKernel.getPreprocessedArt2aEuclidData(
                    aDataMatrix,
                    anOffsetForContrastEnhancement
                );
        } else {
            this.preprocessedData =
                new PreprocessedData(
                    aDataMatrix, 
                    Utils.getMinMaxComponents(aDataMatrix),
                    anOffsetForContrastEnhancement
                );
        }

        this.maximumNumberOfClusters = aMaximumNumberOfClusters;
        this.maximumNumberOfEpochs = aMaximumNumberOfEpochs;
        this.convergenceThreshold = aConvergenceThreshold;
        this.learningParameter = aLearningParameter;
        this.randomSeed = aRandomSeed;
    }

    /**
     * Constructor with default values for
     * MAXIMUM_NUMBER_OF_EPOCHS (= 10), CONVERGENCE_THRESHOLD (= 0.1), 
     * LEARNING_PARAMETER (= 0.01), DEFAULT_OFFSET_FOR_CONTRAST_ENHANCEMENT 
     * (= 0.5) and RANDOM_SEED (= 1).
     *
     * @param aDataMatrix Data matrix with data row vectors (IS NOT CHANGED)
     * @param aMaximumNumberOfClusters Maximum number of clusters (must be in
     * interval [2, number of data row vectors of aDataMatrix])
     * @param anIsDataPreprocessing True: Data preprocessing is performed, false:
     * Otherwise.
     * @throws IllegalArgumentException Thrown if argument is illegal
     */
    public Art2aEuclidKernel(
        float[][] aDataMatrix,
        int aMaximumNumberOfClusters,
        boolean anIsDataPreprocessing
    ) throws IllegalArgumentException {
        this(
            aDataMatrix,
            aMaximumNumberOfClusters,
            DEFAULT_MAXIMUM_NUMBER_OF_EPOCHS, 
            DEFAULT_CONVERGENCE_THRESHOLD, 
            DEFAULT_LEARNING_PARAMETER,
            DEFAULT_OFFSET_FOR_CONTRAST_ENHANCEMENT,
            DEFAULT_RANDOM_SEED,
            anIsDataPreprocessing
        );
    }
    
    /**
     * Constructor.
     *
     * @param aPreprocessedArt2aEuclidData PreprocessedData object
     * created by method Art2aEuclidKernel.getPreprocessedArt2aEuclidData()
     * @param aMaximumNumberOfClusters Maximum number of clusters (must be in 
     * interval [2, number of data row vectors of aDataMatrix])
     * @param aMaximumNumberOfEpochs Maximum number of epochs for training 
     * (must be greater zero)
     * @param aConvergenceThreshold Convergence threshold for cluster centroid 
     * distance (must be greater zero)
     * @param aLearningParameter Learning parameter (must be in interval (0,1))
     * @param aRandomSeed Random seed value for random number generator 
     * (must be greater zero)
     * @throws IllegalArgumentException Thrown if an argument is illegal
     */
    public Art2aEuclidKernel(
        PreprocessedArt2aEuclidData aPreprocessedArt2aEuclidData,
        int aMaximumNumberOfClusters,
        int aMaximumNumberOfEpochs, 
        float aConvergenceThreshold, 
        float aLearningParameter,
        long aRandomSeed
    ) throws IllegalArgumentException {
        // <editor-fold desc="Checks">
        if(aPreprocessedArt2aEuclidData == null) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.Constructor: aPreprocessedArt2aEuclidData is null."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.Constructor: aPreprocessedArt2aEuclidData is null.");
        }
        if(aMaximumNumberOfClusters < 2) {
            Art2aEuclidKernel.LOGGER.log(
                    Level.SEVERE,
                    "Art2aEuclidKernel.Constructor: aMaximumNumberOfClusters must be greater 1."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.Constructor: aMaximumNumberOfClusters must be greater 1.");
        }
        if(aMaximumNumberOfClusters > aPreprocessedArt2aEuclidData.getPreprocessedMatrix().length) {
            aMaximumNumberOfClusters = aPreprocessedArt2aEuclidData.getPreprocessedMatrix().length;
        }
        if(aMaximumNumberOfEpochs <= 0) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.Constructor: aMaximumNumberOfEpochs must be greater zero."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.Constructor: aMaximumNumberOfEpochs must be greater zero.");
        }
        if(aConvergenceThreshold <= 0.0f) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.Constructor: aConvergenceThreshold must be greater zero."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.Constructor: aConvergenceThreshold must be greater zero.");
        }
        if(aLearningParameter <= 0.0f || aLearningParameter >= 1.0f) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.Constructor: aLearningParameter must be in interval (0,1)."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.Constructor: aLearningParameter must be in interval (0,1).");
        }
        if(aRandomSeed <= 0L) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.Constructor: aRandomSeed must be greater 0."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.Constructor: aRandomSeed must be greater/equal 0.");
        }
        //</editor-fold>

        this.preprocessedData = aPreprocessedArt2aEuclidData;
        this.maximumNumberOfClusters = aMaximumNumberOfClusters;
        this.maximumNumberOfEpochs = aMaximumNumberOfEpochs;
        this.convergenceThreshold = aConvergenceThreshold;
        this.learningParameter = aLearningParameter;
        this.randomSeed = aRandomSeed;
    }

    /**
     * Constructor with default values for
     * MAXIMUM_NUMBER_OF_EPOCHS (= 10), CONVERGENCE_THRESHOLD (= 0.1), 
     * LEARNING_PARAMETER (= 0.01) and RANDOM_SEED (= 1).
     *
     * @param aPreprocessedArt2aEuclidData PreprocessedData object created by method
     * Art2aEuclidKernel.getPreprocessedArt2aEuclidData()
     * @param aMaximumNumberOfClusters Maximum number of clusters (must be in
     * interval [2, number of data row vectors of aDataMatrix])
     * @throws IllegalArgumentException Thrown if argument is illegal
     */
    public Art2aEuclidKernel(
        PreprocessedArt2aEuclidData aPreprocessedArt2aEuclidData,
        int aMaximumNumberOfClusters
    ) throws IllegalArgumentException {
        this(
            aPreprocessedArt2aEuclidData,
            aMaximumNumberOfClusters,
            DEFAULT_MAXIMUM_NUMBER_OF_EPOCHS, 
            DEFAULT_CONVERGENCE_THRESHOLD, 
            DEFAULT_LEARNING_PARAMETER,
            DEFAULT_RANDOM_SEED
        );
    }
    //</editor-fold>

    // <editor-fold desc="Public methods">
    /**
     * Performs ART-2a-Euclid clustering and returns corresponding Art2aEuclidResult.
     * Note: Parallelized Rho winner calculation is faster if many detected clusters, sequential Rho winner
     * calculation is faster for a small number of formed clusters. The crossover between both must be evaluated
     * experimentally.
     *
     * @param aVigilance Vigilance parameter (must be in interval (0,1))
     * @param anIsParallelRhoWinnerCalculation True: Rho winner calculation
     * is parallelized, false: Rho winner calculation is sequential.
     * @return Art2aEuclidResult instance
     * @throws IllegalArgumentException Thrown if argument is illegal
     * @throws Exception Thrown if exception occurs which should never happen
     */
    public Art2aEuclidResult getClusterResult(
        float aVigilance,
        boolean anIsParallelRhoWinnerCalculation
    ) throws IllegalArgumentException, Exception {
        // <editor-fold desc="Checks">
        if(aVigilance <= 0.0f || aVigilance >= 1.0f) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.getClusterResult: aVigilance must be in interval (0,1)."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.getClusterResult: aVigilance must be in interval (0,1).");
        }
        //</editor-fold>
        
        try {
            Random tmpRandomNumberGenerator = new Random(this.randomSeed);
            boolean tmpIsClusterOverflow = false;
            
            float[][] tmpDataMatrix = null;
            float[][] tmpContrastEnhancedMatrix = null;
            // Flags array that indicates if data row vectors have a length 
            // of zero (i.e. where all components are equal to zero). True: 
            // Data row vector has a length of zero, false: Otherwise.
            boolean[] tmpDataVectorZeroLengthFlags = null;
            int tmpNumberOfComponents = -1;
            int tmpNumberOfDataVectors = -1;
            if (this.preprocessedData.hasPreprocessedData()) {
                tmpContrastEnhancedMatrix = this.preprocessedData.getPreprocessedMatrix();
                tmpDataVectorZeroLengthFlags = this.preprocessedData.getDataVectorZeroLengthFlags();
                tmpNumberOfDataVectors = tmpContrastEnhancedMatrix.length;
                tmpNumberOfComponents = tmpContrastEnhancedMatrix[0].length;
            } else {
                tmpDataMatrix = this.preprocessedData.getDataMatrix();
                tmpDataVectorZeroLengthFlags = new boolean[tmpDataMatrix.length];
                Utils.fillVector(tmpDataVectorZeroLengthFlags, false);
                tmpNumberOfDataVectors = tmpDataMatrix.length;
                tmpNumberOfComponents = tmpDataMatrix[0].length;
            }
            Utils.MinMaxValue[] tmpMinMaxComponents = this.preprocessedData.getMinMaxComponentsOfDataMatrix();
            
            // Set tmpRhoStar
            float tmpRhoStar = tmpNumberOfComponents * (ONE - aVigilance);

            // Definitions
            float tmpThresholdForContrastEnhancement = 
                Utils.getThresholdForContrastEnhancement(
                    tmpNumberOfComponents,
                    this.preprocessedData.getOffsetForContrastEnhancement()
                );
            // Scaling factor alpha
            float tmpScalingFactor = tmpThresholdForContrastEnhancement;
            
            // Initialize cluster matrix and that for previous epoch (old) with 
            // all row vectors being null
            float[][] tmpClusterMatrix = new float[this.maximumNumberOfClusters][];
            float[][] tmpClusterMatrixOld = new float[this.maximumNumberOfClusters][];
            // Cluster usage flags. True: Cluster is used, false: Cluster is 
            // empty and can be removed.
            boolean[] tmpClusterUsageFlags = new boolean[this.maximumNumberOfClusters];
            // Buffer for Rho values for parallelized Rho winner evaluation
            float[] tmpRhoValueBuffer = null;
            if (anIsParallelRhoWinnerCalculation) {
                tmpRhoValueBuffer = new float[this.maximumNumberOfClusters];
            }

            // Initialize cluster indices for data row vectors with -1 to 
            // indicate missing cluster assignment
            int[] tmpClusterIndexOfDataVector = new int[tmpNumberOfDataVectors];
            Utils.fillVector(tmpClusterIndexOfDataVector, -1);

            // Initialize random indices
            int[] tmpRandomIndices = new int[tmpNumberOfDataVectors];
            for(int i = 0; i < tmpRandomIndices.length; i++) {
                tmpRandomIndices[i] = i;
            }

            // Initialize buffer vector for vector operations
            float[] tmpBufferVector = new float[tmpNumberOfComponents];
            
            // Main clustering loop
            int tmpCurrentNumberOfEpochs = 0;
            int tmpNumberOfDetectedClusters = 0;
            Utils.RhoWinner tmpRhoWinner = new Utils.RhoWinner();
            Utils.ClusterRemovalInfo tmpClusterRemovalInfo = new Utils.ClusterRemovalInfo();
            boolean tmpIsConverged = false;
            while(!tmpIsConverged && tmpCurrentNumberOfEpochs < this.maximumNumberOfEpochs) {
                tmpCurrentNumberOfEpochs++;
                
                // Get random sequence of indices for data row vectors
                Utils.shuffleIndices(tmpRandomIndices, tmpRandomNumberGenerator);

                Arrays.fill(tmpClusterUsageFlags, false);
                for(int i = 0; i < tmpNumberOfDataVectors; i++) {
                    int tmpRandomIndex = tmpRandomIndices[i];
    
                    if (tmpDataVectorZeroLengthFlags[tmpRandomIndex]) {
                        // Shifted data row vector has length of zero: Ignore!
                        continue;
                    }

                    if (this.preprocessedData.hasPreprocessedData()) {
                        Utils.copyVector(tmpContrastEnhancedMatrix[tmpRandomIndex], tmpBufferVector);
                    } else {
                        tmpDataVectorZeroLengthFlags[tmpRandomIndex] = 
                            Art2aEuclidUtils.setContrastEnhancedVector(
                                tmpDataMatrix[tmpRandomIndex],
                                tmpBufferVector,
                                tmpMinMaxComponents,
                                tmpThresholdForContrastEnhancement
                            );
                        if (tmpDataVectorZeroLengthFlags[tmpRandomIndex]) {
                            continue;
                        }
                    }

                    if(tmpNumberOfDetectedClusters == 0) {
                        // Create first cluster
                        Utils.setRowVector(tmpClusterMatrix, tmpBufferVector, tmpNumberOfDetectedClusters);
                        tmpClusterIndexOfDataVector[tmpRandomIndex] = tmpNumberOfDetectedClusters;
                        tmpClusterUsageFlags[tmpNumberOfDetectedClusters] = true;
                        tmpNumberOfDetectedClusters++;
                    } else {
                        // Cluster number is greater than or equal to 1
                        if (anIsParallelRhoWinnerCalculation) {
                            Art2aEuclidKernel.setRhoWinnerParallel(
                                tmpBufferVector,
                                tmpClusterMatrix,
                                tmpNumberOfDetectedClusters,
                                tmpScalingFactor,
                                tmpRhoValueBuffer,
                                tmpRhoWinner
                            );
                        } else {
                            Art2aEuclidKernel.setRhoWinnerSequential(
                                tmpBufferVector,
                                tmpClusterMatrix,
                                tmpNumberOfDetectedClusters,
                                tmpScalingFactor,
                                tmpRhoWinner
                            );
                        }
                        // Assign to existing cluster or increment clusters
                        if(tmpRhoWinner.getIndexOfCluster() < 0 || tmpRhoWinner.getRhoValue() > tmpRhoStar) {
                            // Increment clusters (if possible)
                            if (tmpNumberOfDetectedClusters == this.maximumNumberOfClusters) {
                                tmpIsClusterOverflow = true;
                            } else {
                                // Increment clusters
                                Utils.setRowVector(tmpClusterMatrix, tmpBufferVector, tmpNumberOfDetectedClusters);
                                tmpClusterIndexOfDataVector[tmpRandomIndex] = tmpNumberOfDetectedClusters;
                                tmpClusterUsageFlags[tmpNumberOfDetectedClusters] = true;
                                tmpNumberOfDetectedClusters++;
                            }
                        } else {
                            // Assign to existing winner cluster with modification
                            // Note: tmpBufferVector (= contrast enhanced unit vector)
                            // is used for modification
                            Art2aEuclidKernel.modifyWinnerCluster(
                                tmpBufferVector,
                                tmpClusterMatrix[tmpRhoWinner.getIndexOfCluster()],
                                tmpThresholdForContrastEnhancement,
                                this.learningParameter
                            );
                            tmpClusterIndexOfDataVector[tmpRandomIndex] = tmpRhoWinner.getIndexOfCluster();
                            tmpClusterUsageFlags[tmpRhoWinner.getIndexOfCluster()] = true;
                        }
                    }
                }
                
                Utils.removeEmptyClusters(
                    tmpClusterUsageFlags, 
                    tmpClusterMatrix, 
                    tmpNumberOfDetectedClusters, 
                    tmpClusterRemovalInfo
                );
                if (tmpClusterRemovalInfo.isClusterRemoved()) {
                    tmpNumberOfDetectedClusters = tmpClusterRemovalInfo.getNumberOfDetectedClusters();
                    tmpIsConverged = false;
                } else {
                    tmpIsConverged =
                        Art2aEuclidKernel.isConverged(
                            tmpNumberOfDetectedClusters, 
                            tmpCurrentNumberOfEpochs, 
                            tmpClusterMatrix, 
                            tmpClusterMatrixOld,
                            this.maximumNumberOfEpochs,
                            this.convergenceThreshold
                        );
                }
            }
            // Check if cluster overflow occurred
            if (tmpIsClusterOverflow) {
                // Cluster overflow occurred: Finally assign ALL data vectors
                Art2aEuclidKernel.assignDataVectorsToClusters(
                    tmpNumberOfDetectedClusters,
                    tmpDataVectorZeroLengthFlags,
                    this.preprocessedData,
                    tmpBufferVector,
                    tmpThresholdForContrastEnhancement,
                    tmpClusterMatrix,
                    tmpClusterIndexOfDataVector,
                    tmpClusterUsageFlags
                );
                // Remove possible empty clusters
                Utils.removeEmptyClusters(
                    tmpClusterUsageFlags, 
                    tmpClusterMatrix, 
                    tmpNumberOfDetectedClusters, 
                    tmpClusterRemovalInfo
                );
                tmpNumberOfDetectedClusters = tmpClusterRemovalInfo.getNumberOfDetectedClusters();
            }
            // Check if clusters were removed in last epoch and assure non-empty 
            // clusters in the cluster matrix
            while (tmpClusterRemovalInfo.isClusterRemoved()) {
                // Empty clusters are removed: Assign data vectors again
                Art2aEuclidKernel.assignDataVectorsToClusters(
                    tmpNumberOfDetectedClusters,
                    tmpDataVectorZeroLengthFlags,
                    this.preprocessedData,
                    tmpBufferVector,
                    tmpThresholdForContrastEnhancement,
                    tmpClusterMatrix,
                    tmpClusterIndexOfDataVector,
                    tmpClusterUsageFlags
                );
                Utils.removeEmptyClusters(
                    tmpClusterUsageFlags, 
                    tmpClusterMatrix, 
                    tmpNumberOfDetectedClusters, 
                    tmpClusterRemovalInfo
                );
                tmpNumberOfDetectedClusters = tmpClusterRemovalInfo.getNumberOfDetectedClusters();
            }
            return new Art2aEuclidResult(
                aVigilance,
                tmpThresholdForContrastEnhancement,
                tmpCurrentNumberOfEpochs,
                tmpNumberOfDetectedClusters, 
                tmpClusterIndexOfDataVector,
                tmpClusterMatrix,
                tmpDataVectorZeroLengthFlags,
                tmpIsClusterOverflow,
                tmpIsConverged,
                this.preprocessedData
            );
        } catch (Exception anException) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.getClusterResult: An exception occurred: This should never happen!"
            );
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                anException.toString(), 
                anException
            );
            throw new Exception("Art2aEuclidKernel.getClusterResult: An exception occurred: This should never happen!");
        }
    }

    /**
     * Performs ART-2a-Euclid clustering for specified vigilance parameters and returns corresponding Art2aEuclidResult
     * objects.
     * Note: Parallelized Rho winner evaluation is disabled.
     *
     * @param aVigilances Vigilance parameters (must each be in interval (0,1))
     * @param anIsParallelCalculation True: Calculations are parallelized, false: Calculations are sequential (one
     *                                after another)
     * @return Art2aEuclidResult objects or null if clustering result could
     * not be calculated.
     * @throws IllegalArgumentException Thrown if argument is illegal
     */
    public Art2aEuclidResult[] getClusterResults(
        float[] aVigilances,
        boolean anIsParallelCalculation
    ) throws IllegalArgumentException {
        // <editor-fold desc="Checks">
        if (aVigilances == null || aVigilances.length == 0) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.getClusterResults: aVigilances is null or has length 0."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.getClusterResults: aVigilances is null or has length 0.");
        }
        for (float tmpVigilance : aVigilances) {
            if(tmpVigilance <= 0.0f || tmpVigilance >= 1.0f) {
                Art2aEuclidKernel.LOGGER.log(
                    Level.SEVERE, 
                    "Art2aEuclidKernel.getClusterResults: Vigilance parameter must be in interval (0,1)."
                );
                throw new IllegalArgumentException("Art2aEuclidKernel.getClusterResults: Vigilance parameter must be in interval (0,1).");
            }
        }
        //</editor-fold>

        if (anIsParallelCalculation) {
            try {
                Art2aEuclidResult[] tmpParallelResults = new Art2aEuclidResult[aVigilances.length];
                IntStream.range(0, aVigilances.length).parallel().forEach(
                        i ->
                        {
                            try {
                                // Note: Parallel Rho winner calculation is disabled: Parameter false.
                                tmpParallelResults[i] = this.getClusterResult(aVigilances[i], false);
                            } catch (Exception anException) {
                                Art2aEuclidKernel.LOGGER.log(
                                        Level.SEVERE,
                                        "Art2aEuclidKernel.getClusterResults: An exception occurred in common fork-join pool: This should never happen."
                                );
                                tmpParallelResults[i] = null;
                            }
                        }
                );
                boolean tmpIsSuccessful = true;
                for (int i = 0; i < aVigilances.length; i++) {
                    if (tmpParallelResults[i] == null) {
                        tmpIsSuccessful = false;
                        break;
                    }
                }
                if (tmpIsSuccessful) {
                    return tmpParallelResults;
                } else {
                    return null;
                }
            } catch (Exception anException) {
                Art2aEuclidKernel.LOGGER.log(
                        Level.SEVERE,
                        "Art2aEuclidKernel.getClusterResults: An exception occurred: This should never happen."
                );
                return null;
            }
        } else {
            try {
                Art2aEuclidResult[] tmpSequentialResults = new Art2aEuclidResult[aVigilances.length];
                for (int i = 0; i < aVigilances.length; i++) {
                    // Note: Parallel Rho winner evaluations is disabled: Parameter false.
                    tmpSequentialResults[i] = this.getClusterResult(aVigilances[i], false);
                }
                return tmpSequentialResults;
            } catch (Exception anException) {
                Art2aEuclidKernel.LOGGER.log(
                        Level.SEVERE,
                        "Art2aEuclidKernel.getClusterResults: An exception occurred: This should never happen."
                );
                return null;
            }
        }
    }
    
    /**
     * Nearest (smaller) indices of approximants to the desired number of 
     * representatives.
     * 
     * @param aNumberOfRepresentatives Number of representatives (MUST be 
     * greater or equal to 2)
     * @param aVigilanceMin Minimal vigilance parameter (must be in interval 
     * (0,1), a good default value is 0.0001f)
     * @param aVigilanceMax Maximal vigilance parameter (must be in interval
     * (0,1), a good default value is 0.9999f)
     * @param aNumberOfTrialSteps Number of trial steps (MUST be greater or
     * equal to 1, a good default value is 32)
     * @param anIsParallelRhoWinnerCalculation True: Rho winner calculation
     * is parallelized, false: Rho winner calculation is sequential.
     * @return Nearest (smaller) indices of approximants to the desired number
     * of representatives.
     * @throws IllegalArgumentException Thrown if an argument is illegal
     * @throws Exception Thrown if exception occurs which should never happen
     */
    public int[] getRepresentatives(
        int aNumberOfRepresentatives,
        float aVigilanceMin,
        float aVigilanceMax,
        int aNumberOfTrialSteps,
        boolean anIsParallelRhoWinnerCalculation
    ) throws IllegalArgumentException, Exception {
        // <editor-fold desc="Checks">
        if(aNumberOfRepresentatives < 2) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.getRepresentatives: aNumberOfRepresentatives must be greater/equal 2."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.getRepresentatives: aNumberOfRepresentatives must be greater/equal 2.");
        }
        if(aVigilanceMin <= 0.0f || aVigilanceMin >= 1.0f) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.getRepresentatives: aVigilanceMin must be in interval (0,1)."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.getRepresentatives: aVigilanceMin must be in interval (0,1).");
        }
        if(aVigilanceMax <= 0.0f || aVigilanceMax >= 1.0f) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.getRepresentatives: aVigilanceMax must be in interval (0,1)."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.getRepresentatives: aVigilanceMax must be in interval (0,1).");
        }
        if(aVigilanceMin >= aVigilanceMax) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.getRepresentatives: aVigilanceMin must be smaller than aVigilanceMax."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.getRepresentatives: aVigilanceMin must be smaller than aVigilanceMax.");
        }
        if(aNumberOfTrialSteps < 1) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.getRepresentatives: aNumberOfTrialSteps must be greater/equal 1."
            );
            throw new IllegalArgumentException("Art2aEuclidKernel.getRepresentatives: aNumberOfTrialSteps must be greater/equal 1.");
        }
        //</editor-fold>

        try {
            Art2aEuclidResult tmpArt2aEuclidResult = this.getClusterResult(aVigilanceMin, anIsParallelRhoWinnerCalculation);
            int[] tmpRepresentativeIndicesOfClusters = tmpArt2aEuclidResult.getRepresentativeIndicesOfClusters();
            if (tmpArt2aEuclidResult.getNumberOfDetectedClusters() > aNumberOfRepresentatives) {
                return tmpRepresentativeIndicesOfClusters;
            }
            tmpArt2aEuclidResult = this.getClusterResult(aVigilanceMax, anIsParallelRhoWinnerCalculation);
            if (tmpArt2aEuclidResult.getNumberOfDetectedClusters() < aNumberOfRepresentatives) {
                return tmpArt2aEuclidResult.getRepresentativeIndicesOfClusters();
            }

            float tmpVigilanceMin = aVigilanceMin;
            float tmpVigilanceMax = aVigilanceMax;
            for (int i = 0; i < aNumberOfTrialSteps; i++) {
                float tmpVigilanceMean = (tmpVigilanceMin + tmpVigilanceMax) / 2.0f;
                tmpArt2aEuclidResult = this.getClusterResult(tmpVigilanceMean, anIsParallelRhoWinnerCalculation);
                if (tmpArt2aEuclidResult.getNumberOfDetectedClusters() > aNumberOfRepresentatives) {
                    tmpVigilanceMax = tmpVigilanceMean;
                } else if (tmpArt2aEuclidResult.getNumberOfDetectedClusters() < aNumberOfRepresentatives) {
                    tmpVigilanceMin = tmpVigilanceMean;
                    tmpRepresentativeIndicesOfClusters = tmpArt2aEuclidResult.getRepresentativeIndicesOfClusters();
                } else {
                    return tmpArt2aEuclidResult.getRepresentativeIndicesOfClusters();
                }
            }
            return tmpRepresentativeIndicesOfClusters;
        } catch (Exception anException) {
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                "Art2aEuclidKernel.getRepresentatives: An exception occurred: This should never happen!"
            );
            Art2aEuclidKernel.LOGGER.log(
                Level.SEVERE, 
                anException.toString(), 
                anException
            );
            throw anException;
        }
    }
    //</editor-fold>
    // <editor-fold desc="Public static methods">
    /**
     * Creates PreprocessedData object with preprocessed ART-2a-Euclid data for maximum
     * speed  of the clustering process. The PreprocessedData object allocates
     * about the same memory as aDataMatrix.
     * <br>
     * Note: There a no checks! Check aDataMatrix in advance with method
     * Utils.isDataMatrixValid().
     * <br>
     * Note: aDataMatrix could be set to null after this operation to release  
     * its memory.

     * @param aDataMatrix Data matrix (IS NOT CHANGED and MUST BE VALID: Check 
     * with Utils.isDataMatrixValid() in advance)
     * @param anOffsetForContrastEnhancement Offset for contrast enhancement 
     * (must be greater zero)
     * @return PreprocessedData object for maximum clustering speed but with
     * additionally allocated memory (about the same memory as aDataMatrix)
     */
    public static PreprocessedArt2aEuclidData getPreprocessedArt2aEuclidData(
        float[][] aDataMatrix,
        float anOffsetForContrastEnhancement
    ) {
        int tmpNumberOfComponents = aDataMatrix[0].length;
        float tmpThresholdForContrastEnhancement = 
            Utils.getThresholdForContrastEnhancement(
                tmpNumberOfComponents,
                anOffsetForContrastEnhancement
            );
        
        // Initialize flags array for scaled data row vectors which have a 
        // length of zero (i.e. where all components are equal to zero)
        boolean[] tmpDataVectorZeroLengthFlags = new boolean[aDataMatrix.length];
        Utils.fillVector(tmpDataVectorZeroLengthFlags, false);

        float[][] tmpContrastEnhancedMatrix = new float[aDataMatrix.length][];
        
        Utils.MinMaxValue[] tmpMinMaxComponents = Utils.getMinMaxComponents(aDataMatrix);

        for(int i = 0; i < aDataMatrix.length; i++) {
            float[] tmpContrastEnhancedVector = new float[tmpNumberOfComponents];
            tmpDataVectorZeroLengthFlags[i] = 
                Art2aEuclidUtils.setContrastEnhancedVector(
                    aDataMatrix[i],
                    tmpContrastEnhancedVector,
                    tmpMinMaxComponents,
                    tmpThresholdForContrastEnhancement
                );
            tmpContrastEnhancedMatrix[i] = tmpContrastEnhancedVector;
        }
        return new PreprocessedArt2aEuclidData(
            tmpContrastEnhancedMatrix,
            tmpDataVectorZeroLengthFlags,
            tmpMinMaxComponents,
            anOffsetForContrastEnhancement
        );
    }

    /**
     * Creates PreprocessedData object with preprocessed ART-2a-Euclid data for maximum
     * speed of the clustering process. The PreprocessedData object allocates
     * about twice the memory of aDataMatrix. A default value of 1.0 is used 
     * for the offset for contrast enhancement.
     * <br>
     * Note: aDataMatrix could be set to null after this operation to release  
     * its memory.

     * @param aDataMatrix Data matrix (IS NOT CHANGED and MUST BE VALID: Check 
     * with Utils.isDataMatrixValid() in advance)
     * @return PreprocessedData object for maximum clustering speed but with
     * additionally allocated memory (about the same memory as aDataMatrix)
     */
    public static PreprocessedArt2aEuclidData getPreprocessedArt2aEuclidData(
        float[][] aDataMatrix
    ) {
        return Art2aEuclidKernel.getPreprocessedArt2aEuclidData(aDataMatrix, DEFAULT_OFFSET_FOR_CONTRAST_ENHANCEMENT);
    }
    //</editor-fold>

    //<editor-fold desc="Private static methods">
    /**
     * Assigns data vectors to clusters
     *
     * @param aNumberOfDetectedClusters Number of detected clusters
     * @param aDataVectorZeroLengthFlags Flags array that indicates if scaled
     * data row vectors have a length of zero (i.e. where all components are
     * equal to zero). True: Scaled data row vector has a length of zero
     * (corresponding contrast enhanced unit vector is set to null in this
     * case), false: Otherwise.
     * @param aPreprocessedArt2aEuclidData PreprocessedData instance (IS NOT CHANGED)
     * @param aBufferVector Buffer vector (MUST BE ALREADY INSTANTIATED)
     * @param aThresholdForContrastEnhancement Threshold for contrast
     * enhancement
     * @param aClusterMatrix Cluster matrix (IS NOT CHANGED)
     * @param aClusterIndexOfDataVector Cluster index of data vector (MAY BE
     * CHANGED and MUST ALREADY BE INSTANTIATED)
     * @param aClusterUsageFlags Flags for cluster usage. True: Cluster is used,
     * false: Cluster is empty and has to be removed (MAY BE CHANGED and MUST
     * ALREADY BE INSTANTIATED)
     */
    private static void assignDataVectorsToClusters(
            int aNumberOfDetectedClusters,
            boolean[] aDataVectorZeroLengthFlags,
            PreprocessedData aPreprocessedArt2aEuclidData,
            float[] aBufferVector,
            float aThresholdForContrastEnhancement,
            float[][]aClusterMatrix,
            int[] aClusterIndexOfDataVector,
            boolean[] aClusterUsageFlags
    ) {
        // Assign data vectors to clusters (last pass)
        Arrays.fill(aClusterUsageFlags, false);
        for (int i = 0; i < aDataVectorZeroLengthFlags.length; i++) {
            if (!aDataVectorZeroLengthFlags[i]) {
                if (aPreprocessedArt2aEuclidData.hasPreprocessedData()) {
                    aBufferVector = aPreprocessedArt2aEuclidData.getPreprocessedMatrix()[i];
                } else {
                    // Check of length is NOT necessary
                    Art2aEuclidUtils.setContrastEnhancedVector(
                            aPreprocessedArt2aEuclidData.getDataMatrix()[i],
                            aBufferVector,
                            aPreprocessedArt2aEuclidData.getMinMaxComponentsOfDataMatrix(),
                            aThresholdForContrastEnhancement
                    );
                }
                int tmpWinnerClusterIndex =
                        Art2aEuclidKernel.getClusterIndex(
                            aBufferVector,
                            aNumberOfDetectedClusters,
                            aClusterMatrix
                        );
                aClusterIndexOfDataVector[i] = tmpWinnerClusterIndex;
                aClusterUsageFlags[tmpWinnerClusterIndex] = true;
            }
        }
    }

    /**
     * Returns index of cluster for contrast enhanced vector
     *
     * @param aContrastEnhancedVector Contrast enhanced vector
     * @param aNumberOfDetectedClusters Number of detected clusters
     * @param aClusterMatrix Cluster matrix
     * @return Index of cluster for contrast enhanced unit vector
     */
    private static int getClusterIndex(
            float[] aContrastEnhancedVector,
            int aNumberOfDetectedClusters,
            float[][] aClusterMatrix
    ) {
        float tmpMinSquaredDistance = Float.MAX_VALUE;
        int tmpWinnerClusterIndex = -1;
        for (int i = 0; i < aNumberOfDetectedClusters; i++) {
            float tmpSquaredDistance = Utils.getSquaredDistance(aContrastEnhancedVector, aClusterMatrix[i]);
            if (tmpSquaredDistance < tmpMinSquaredDistance) {
                tmpMinSquaredDistance = tmpSquaredDistance;
                tmpWinnerClusterIndex = i;
            }
        }
        return tmpWinnerClusterIndex;
    }

    /**
     * Determines convergence of clustering process.
     * Note: No checks are performed.
     *
     * @param aNumberOfDetectedClusters Number of detected clusters
     * @param anEpoch Current epochs
     * @param aClusterCentroidMatrix Cluster centroid matrix with centroid row
     * vectors
     * @param aClusterCentroidMatrixOld Cluster centroid matrix with
     * centroid row vectors of the previous epoch
     * @param aMaximumNumberOfEpochs Maximum number of epochs
     * @param aConvergenceThreshold Convergence threshold
     * @return True if clustering process has converged, false otherwise.
     */
    private static boolean isConverged(
            int aNumberOfDetectedClusters,
            int anEpoch,
            float[][] aClusterCentroidMatrix,
            float[][] aClusterCentroidMatrixOld,
            int aMaximumNumberOfEpochs,
            float aConvergenceThreshold
    ) {
        if (anEpoch == 1) {
            // Convergence check needs at least 2 epochs
            Utils.copyRows(aClusterCentroidMatrix, aClusterCentroidMatrixOld, aNumberOfDetectedClusters);
            return false;
        } else {
            float tmpSquaredConvergenceThreshold = aConvergenceThreshold * aConvergenceThreshold;
            boolean tmpIsConverged = false;
            if(anEpoch < aMaximumNumberOfEpochs) {
                // Check convergence by evaluating the similarity (scalar product)
                // of the cluster vectors of this and the previous epoch
                tmpIsConverged = true;
                for (int i = 0; i < aNumberOfDetectedClusters; i++) {
                    if (
                            aClusterCentroidMatrixOld[i] == null ||
                                    Utils.getSquaredDistance(
                                            aClusterCentroidMatrix[i],
                                            aClusterCentroidMatrixOld[i]
                                    ) > tmpSquaredConvergenceThreshold
                    ) {
                        tmpIsConverged = false;
                        break;
                    }
                }
                if(!tmpIsConverged) {
                    Utils.copyRows(aClusterCentroidMatrix, aClusterCentroidMatrixOld, aNumberOfDetectedClusters);
                }
            }
            return tmpIsConverged;
        }
    }

    /**
     * Modifies winner cluster (see code).
     * Note: aContrastEnhancedVector is used for modification and may be
     * changed.
     * Note: No checks are performed.
     *
     * @param aContrastEnhancedVector Contrast enhanced unit vector for
     * modification (MAY BE CHANGED)
     * @param aWinnerClusterVector Winner cluster centroid vector (MAY BE CHANGED)
     * @param aThresholdForContrastEnhancement Threshold for contrast enhancement
     * @param aLearningParameter  Learning parameter
     */
    private static void modifyWinnerCluster(
            float[] aContrastEnhancedVector,
            float[] aWinnerClusterVector,
            float aThresholdForContrastEnhancement,
            float aLearningParameter
    ) {
        // Note: aContrastEnhancedVector is used for modification
        for(int j = 0; j < aWinnerClusterVector.length; j++) {
            if(aWinnerClusterVector[j] <= aThresholdForContrastEnhancement) {
                aContrastEnhancedVector[j] = 0.0f;
            }
        }
        float tmpFactor = ONE - aLearningParameter;
        for(int j = 0; j < aWinnerClusterVector.length; j++) {
            aContrastEnhancedVector[j] = aLearningParameter * aContrastEnhancedVector[j] + tmpFactor * aWinnerClusterVector[j];
        }
        Utils.copyVector(aContrastEnhancedVector, aWinnerClusterVector);
    }

    /**
     * Sets rho winner with the rho value and the cluster index of the winner
     * (see code). If the cluster index is negative the first scaled rho value
     * is the winner.
     *
     * @param aContrastEnhancedVector Contrast enhanced unit vector (IS NOT CHANGED)
     * @param aClusterMatrix Cluster matrix (IS NOT CHANGED)
     * @param aNumberOfDetectedClusters Number of detected clusters
     * @param aScalingFactor Scaling factor
     * @param aRhoWinner Rho winner: Is set with the rho value and the cluster
     * index of the winner. If the cluster index is negative the first scaled
     * rho value is the winner.
     */
    private static void setRhoWinnerSequential(
            float[] aContrastEnhancedVector,
            float[][] aClusterMatrix,
            int aNumberOfDetectedClusters,
            float aScalingFactor,
            Utils.RhoWinner aRhoWinner
    ) {
        // Calculate first rho value
        float tmpRhoValue = Utils.getSumOfSquaredDifferences(aContrastEnhancedVector, aScalingFactor);
        // Set winner index to negative value
        int tmpIndex = -1;
        // Calculate other rho values
        for(int i = 0; i < aNumberOfDetectedClusters; i++) {
            float tmpRhoForCluster = Utils.getSquaredDistance(aContrastEnhancedVector, aClusterMatrix[i]);
            if(tmpRhoForCluster < tmpRhoValue) {
                tmpRhoValue = tmpRhoForCluster;
                tmpIndex = i;
            }
        }
        aRhoWinner.setRhoWinner(tmpRhoValue, tmpIndex);
    }

    /**
     * Sets rho winner with the rho value and the cluster index of the winner
     * (see code). If the cluster index is negative the first scaled rho value
     * is the winner.
     * Note: A parallelized stream is used for calculation.
     *
     * @param aContrastEnhancedVector Contrast enhanced vector (IS NOT CHANGED)
     * @param aClusterMatrix Cluster matrix (IS NOT CHANGED)
     * @param aNumberOfDetectedClusters Number of detected clusters
     * @param aScalingFactor Scaling factor
     * @param aRhoValueBuffer Buffer for Rho values
     * @param aRhoWinner Rho winner: Is set with the rho value and the cluster
     * index of the winner. If the cluster index is negative the first scaled
     * rho value is the winner.
     */
    private static void setRhoWinnerParallel(
            float[] aContrastEnhancedVector,
            float[][] aClusterMatrix,
            int aNumberOfDetectedClusters,
            float aScalingFactor,
            float[] aRhoValueBuffer,
            Utils.RhoWinner aRhoWinner
    ) {
        // Calculate first rho value
        float tmpRhoValue = Utils.getSumOfSquaredDifferences(aContrastEnhancedVector, aScalingFactor);
        // Set winner index to negative value
        int tmpIndex = -1;
        // Calculate other rho values
        IntStream.range(0, aNumberOfDetectedClusters).parallel().forEach(
                i -> aRhoValueBuffer[i] = Utils.getSquaredDistance(aContrastEnhancedVector, aClusterMatrix[i])
        );
        for(int i = 0; i < aNumberOfDetectedClusters; i++) {
            if(aRhoValueBuffer[i] < tmpRhoValue) {
                tmpRhoValue = aRhoValueBuffer[i];
                tmpIndex = i;
            }
        }
        aRhoWinner.setRhoWinner(tmpRhoValue, tmpIndex);
    }
    //</editor-fold>

}
